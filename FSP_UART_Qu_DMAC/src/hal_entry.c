#include "hal_data.h"
#include "FSP_LED.h"
#include "FSP_Button.h"
#include "FSP_ICU_key.h"
#include "FSP_Systick.h"
#include "FSP_UART.h"
#include "circular_queue.h"
#include "FSP_DMAC.h"

//extern volatile bool key1_sw2_press;
//extern volatile bool key2_sw3_press;
extern const uint32_t SRam_Buffer[BUFFER_SIZE];
extern uint32_t Rom_Buffer[BUFFER_SIZE];
extern volatile bool dmac0_compelete_transfmission_sign;
extern volatile uint16_t dmac0_transfer_count;

uint8_t Read_Buffer[DATA_LEN];
uint16_t Read_Length;

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER



void BufferShow_HexData(const uint32_t *pBUffer,uint16_t Buffer_len)
{
    while(Buffer_len)
    {
        if((Buffer_len % 4) == 0)
            printf("\r\n\t");
        printf("0x%08x",(unsigned int)*pBUffer);
        Buffer_len --;
        pBUffer++;
    }
    printf("\r\n");
}
/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
    fsp_err_t err = FSP_SUCCESS;
    
    FSP_UART_Init();
    FSP_Button_Init();
    FSP_Dmac_Init();
    printf("Hello\r\n");
    Queue_Init(&Circular_queue);
    
    dmac0_compelete_transfmission_sign = false;
    err = R_DMAC_Enable(&g_transfer_dmac0_ctrl);
    assert(err == FSP_SUCCESS);
    
#ifndef USE_MY_TRANSFER_INFOR_CONFIG
    R_DMAC_SoftwareStart(&g_transfer_dmac0_ctrl, TRANSFER_START_MODE_REPEAT);
#else
#if(DMAC_TRANSFER_MODE == DMAC_TRANSFER_NORMAL_MODE)
    R_DMAC_SoftwareStart(&g_transfer_dmac0_ctrl, TRANSFER_START_MODE_REPEAT);
#elif(DMAC_TRANSFER_MODE == TRANSFER_MODE_REPEAT)
    R_DMAC_SoftwareStart(&g_transfer_dmac0_ctrl, TRANSFER_START_MODE_REPEAT);   
#elif(DMAC_TRANSFER_MODE == TRANSFER_MODE_BLOCK)
    R_DMAC_SoftwareStart(&g_transfer_dmac0_ctrl, TRANSFER_START_MODE_REPEAT);   
#elif(DMAC_TRANSFER_MODE == TRANSFER_MODE_REPEAT_BLOCK)
    R_DMAC_SoftwareStart(&g_transfer_dmac0_ctrl, TRANSFER_START_MODE_REPEAT); 
#endif
#endif
    while(false == dmac0_compelete_transfmission_sign);
    R_BSP_SoftwareDelay(5,BSP_DELAY_UNITS_MILLISECONDS);
    printf("\r\nCount:%d\r\n",dmac0_transfer_count);
    BufferShow_HexData(Rom_Buffer,32);
    while(1)
    {
        
        /*uart队列发送代码*/
//        if(FSP_Scan_Key(FSP_KEY1_SW2_Pin) == Button_ON|| FSP_Scan_Key(FSP_KEY2_SW3_Pin) == Button_ON)
//            printf("HELLO\n");
//        if(!Queue_isEmpty(&Circular_queue))
//        {
//            Read_Length = Queue_HadUse(&Circular_queue);
//            if(Read_Length >= 1)
//            {
//                printf("Read_Length = %d:",Read_Length);
//                memset(Read_Buffer,0,DATA_LEN);
//                Queue_Read(&Circular_queue,Read_Buffer,Read_Length);
//                printf("%s\n",Read_Buffer);
//            }
//        }
//        R_BSP_SoftwareDelay(1,BSP_DELAY_UNITS_MILLISECONDS);
    }
    
    
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
